// Code generated by mockery v2.20.2. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	repo "github.com/walkline/ToCloud9/apps/mailserver/repo"
)

// MailRepo is an autogenerated mock type for the MailRepo type
type MailRepo struct {
	mock.Mock
}

// AddMail provides a mock function with given fields: ctx, realmID, mail
func (_m *MailRepo) AddMail(ctx context.Context, realmID uint32, mail *repo.Mail) error {
	ret := _m.Called(ctx, realmID, mail)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, *repo.Mail) error); ok {
		r0 = rf(ctx, realmID, mail)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteItemsWithIDs provides a mock function with given fields: ctx, realmID, itemIDs
func (_m *MailRepo) DeleteItemsWithIDs(ctx context.Context, realmID uint32, itemIDs []uint64) error {
	ret := _m.Called(ctx, realmID, itemIDs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, []uint64) error); ok {
		r0 = rf(ctx, realmID, itemIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteMailItemsWithIDs provides a mock function with given fields: ctx, realmID, itemIDs
func (_m *MailRepo) DeleteMailItemsWithIDs(ctx context.Context, realmID uint32, itemIDs []uint64) error {
	ret := _m.Called(ctx, realmID, itemIDs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, []uint64) error); ok {
		r0 = rf(ctx, realmID, itemIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteMailsWithoutAttachments provides a mock function with given fields: ctx, realmID, IDs
func (_m *MailRepo) DeleteMailsWithoutAttachments(ctx context.Context, realmID uint32, IDs []uint) error {
	ret := _m.Called(ctx, realmID, IDs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, []uint) error); ok {
		r0 = rf(ctx, realmID, IDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExpiredMails provides a mock function with given fields: ctx, realmID
func (_m *MailRepo) ExpiredMails(ctx context.Context, realmID uint32) ([]repo.Mail, error) {
	ret := _m.Called(ctx, realmID)

	var r0 []repo.Mail
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) ([]repo.Mail, error)); ok {
		return rf(ctx, realmID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32) []repo.Mail); ok {
		r0 = rf(ctx, realmID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repo.Mail)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, realmID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MailByID provides a mock function with given fields: ctx, realmID, mailID
func (_m *MailRepo) MailByID(ctx context.Context, realmID uint32, mailID uint) (*repo.Mail, error) {
	ret := _m.Called(ctx, realmID, mailID)

	var r0 *repo.Mail
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint) (*repo.Mail, error)); ok {
		return rf(ctx, realmID, mailID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint) *repo.Mail); ok {
		r0 = rf(ctx, realmID, mailID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*repo.Mail)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint) error); ok {
		r1 = rf(ctx, realmID, mailID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MailItemsIDsByMailIDs provides a mock function with given fields: ctx, realmID, IDs
func (_m *MailRepo) MailItemsIDsByMailIDs(ctx context.Context, realmID uint32, IDs []uint) ([]uint64, error) {
	ret := _m.Called(ctx, realmID, IDs)

	var r0 []uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, []uint) ([]uint64, error)); ok {
		return rf(ctx, realmID, IDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, []uint) []uint64); ok {
		r0 = rf(ctx, realmID, IDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]uint64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, []uint) error); ok {
		r1 = rf(ctx, realmID, IDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MailListForPlayer provides a mock function with given fields: ctx, realmID, playerGUID
func (_m *MailRepo) MailListForPlayer(ctx context.Context, realmID uint32, playerGUID uint64) ([]repo.Mail, error) {
	ret := _m.Called(ctx, realmID, playerGUID)

	var r0 []repo.Mail
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint64) ([]repo.Mail, error)); ok {
		return rf(ctx, realmID, playerGUID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint64) []repo.Mail); ok {
		r0 = rf(ctx, realmID, playerGUID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repo.Mail)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint64) error); ok {
		r1 = rf(ctx, realmID, playerGUID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveMailItem provides a mock function with given fields: ctx, realmID, mailID, mailItemGUID
func (_m *MailRepo) RemoveMailItem(ctx context.Context, realmID uint32, mailID uint, mailItemGUID uint64) error {
	ret := _m.Called(ctx, realmID, mailID, mailItemGUID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint, uint64) error); ok {
		r0 = rf(ctx, realmID, mailID, mailItemGUID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveMailItemForPlayer provides a mock function with given fields: ctx, realmID, mailID, mailItemGUID, playerGUID
func (_m *MailRepo) RemoveMailItemForPlayer(ctx context.Context, realmID uint32, mailID uint, mailItemGUID uint64, playerGUID uint64) error {
	ret := _m.Called(ctx, realmID, mailID, mailItemGUID, playerGUID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint, uint64, uint64) error); ok {
		r0 = rf(ctx, realmID, mailID, mailItemGUID, playerGUID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveMailMoney provides a mock function with given fields: ctx, realmID, mailID
func (_m *MailRepo) RemoveMailMoney(ctx context.Context, realmID uint32, mailID uint) (int32, error) {
	ret := _m.Called(ctx, realmID, mailID)

	var r0 int32
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint) (int32, error)); ok {
		return rf(ctx, realmID, mailID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint) int32); ok {
		r0 = rf(ctx, realmID, mailID)
	} else {
		r0 = ret.Get(0).(int32)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint) error); ok {
		r1 = rf(ctx, realmID, mailID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveMailMoneyForPlayer provides a mock function with given fields: ctx, realmID, mailID, playerGUID
func (_m *MailRepo) RemoveMailMoneyForPlayer(ctx context.Context, realmID uint32, mailID uint, playerGUID uint64) (int32, error) {
	ret := _m.Called(ctx, realmID, mailID, playerGUID)

	var r0 int32
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint, uint64) (int32, error)); ok {
		return rf(ctx, realmID, mailID, playerGUID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint, uint64) int32); ok {
		r0 = rf(ctx, realmID, mailID, playerGUID)
	} else {
		r0 = ret.Get(0).(int32)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint, uint64) error); ok {
		r1 = rf(ctx, realmID, mailID, playerGUID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMailFlagsMaskForPlayer provides a mock function with given fields: ctx, realmID, playerGUID, mailID, mask
func (_m *MailRepo) UpdateMailFlagsMaskForPlayer(ctx context.Context, realmID uint32, playerGUID uint64, mailID uint, mask repo.MailFlagMask) error {
	ret := _m.Called(ctx, realmID, playerGUID, mailID, mask)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint64, uint, repo.MailFlagMask) error); ok {
		r0 = rf(ctx, realmID, playerGUID, mailID, mask)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateMailItemsOwner provides a mock function with given fields: ctx, realmID, mailID, newReceiverID
func (_m *MailRepo) UpdateMailItemsOwner(ctx context.Context, realmID uint32, mailID uint, newReceiverID uint64) error {
	ret := _m.Called(ctx, realmID, mailID, newReceiverID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint, uint64) error); ok {
		r0 = rf(ctx, realmID, mailID, newReceiverID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateMailWithoutAttachments provides a mock function with given fields: ctx, realmID, mail
func (_m *MailRepo) UpdateMailWithoutAttachments(ctx context.Context, realmID uint32, mail *repo.Mail) error {
	ret := _m.Called(ctx, realmID, mail)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, *repo.Mail) error); ok {
		r0 = rf(ctx, realmID, mail)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewMailRepo interface {
	mock.TestingT
	Cleanup(func())
}

// NewMailRepo creates a new instance of MailRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMailRepo(t mockConstructorTestingTNewMailRepo) *MailRepo {
	mock := &MailRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
