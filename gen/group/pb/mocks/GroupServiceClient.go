// Code generated by mockery v2.20.2. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	pb "github.com/walkline/ToCloud9/gen/group/pb"
)

// GroupServiceClient is an autogenerated mock type for the GroupServiceClient type
type GroupServiceClient struct {
	mock.Mock
}

// AcceptInvite provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) AcceptInvite(ctx context.Context, in *pb.AcceptInviteParams, opts ...grpc.CallOption) (*pb.AcceptInviteResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.AcceptInviteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.AcceptInviteParams, ...grpc.CallOption) (*pb.AcceptInviteResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.AcceptInviteParams, ...grpc.CallOption) *pb.AcceptInviteResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.AcceptInviteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.AcceptInviteParams, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChangeLeader provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) ChangeLeader(ctx context.Context, in *pb.ChangeLeaderParams, opts ...grpc.CallOption) (*pb.ChangeLeaderResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.ChangeLeaderResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.ChangeLeaderParams, ...grpc.CallOption) (*pb.ChangeLeaderResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.ChangeLeaderParams, ...grpc.CallOption) *pb.ChangeLeaderResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.ChangeLeaderResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.ChangeLeaderParams, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConvertToRaid provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) ConvertToRaid(ctx context.Context, in *pb.ConvertToRaidParams, opts ...grpc.CallOption) (*pb.ConvertToRaidResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.ConvertToRaidResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.ConvertToRaidParams, ...grpc.CallOption) (*pb.ConvertToRaidResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.ConvertToRaidParams, ...grpc.CallOption) *pb.ConvertToRaidResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.ConvertToRaidResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.ConvertToRaidParams, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroup provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) GetGroup(ctx context.Context, in *pb.GetGroupRequest, opts ...grpc.CallOption) (*pb.GetGroupResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.GetGroupResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.GetGroupRequest, ...grpc.CallOption) (*pb.GetGroupResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.GetGroupRequest, ...grpc.CallOption) *pb.GetGroupResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.GetGroupResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.GetGroupRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroupByMember provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) GetGroupByMember(ctx context.Context, in *pb.GetGroupByMemberRequest, opts ...grpc.CallOption) (*pb.GetGroupResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.GetGroupResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.GetGroupByMemberRequest, ...grpc.CallOption) (*pb.GetGroupResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.GetGroupByMemberRequest, ...grpc.CallOption) *pb.GetGroupResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.GetGroupResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.GetGroupByMemberRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroupIDByPlayer provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) GetGroupIDByPlayer(ctx context.Context, in *pb.GetGroupIDByPlayerRequest, opts ...grpc.CallOption) (*pb.GetGroupIDByPlayerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.GetGroupIDByPlayerResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.GetGroupIDByPlayerRequest, ...grpc.CallOption) (*pb.GetGroupIDByPlayerResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.GetGroupIDByPlayerRequest, ...grpc.CallOption) *pb.GetGroupIDByPlayerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.GetGroupIDByPlayerResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.GetGroupIDByPlayerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Invite provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) Invite(ctx context.Context, in *pb.InviteParams, opts ...grpc.CallOption) (*pb.InviteResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.InviteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.InviteParams, ...grpc.CallOption) (*pb.InviteResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.InviteParams, ...grpc.CallOption) *pb.InviteResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.InviteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.InviteParams, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Leave provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) Leave(ctx context.Context, in *pb.GroupLeaveParams, opts ...grpc.CallOption) (*pb.GroupLeaveResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.GroupLeaveResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.GroupLeaveParams, ...grpc.CallOption) (*pb.GroupLeaveResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.GroupLeaveParams, ...grpc.CallOption) *pb.GroupLeaveResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.GroupLeaveResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.GroupLeaveParams, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendMessage provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) SendMessage(ctx context.Context, in *pb.SendGroupMessageParams, opts ...grpc.CallOption) (*pb.SendGroupMessageResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.SendGroupMessageResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SendGroupMessageParams, ...grpc.CallOption) (*pb.SendGroupMessageResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SendGroupMessageParams, ...grpc.CallOption) *pb.SendGroupMessageResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.SendGroupMessageResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.SendGroupMessageParams, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetDungeonDifficulty provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) SetDungeonDifficulty(ctx context.Context, in *pb.SetDungeonDifficultyRequest, opts ...grpc.CallOption) (*pb.SetDungeonDifficultyResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.SetDungeonDifficultyResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SetDungeonDifficultyRequest, ...grpc.CallOption) (*pb.SetDungeonDifficultyResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SetDungeonDifficultyRequest, ...grpc.CallOption) *pb.SetDungeonDifficultyResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.SetDungeonDifficultyResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.SetDungeonDifficultyRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetGroupTargetIcon provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) SetGroupTargetIcon(ctx context.Context, in *pb.SetGroupTargetIconRequest, opts ...grpc.CallOption) (*pb.SetGroupTargetIconResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.SetGroupTargetIconResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SetGroupTargetIconRequest, ...grpc.CallOption) (*pb.SetGroupTargetIconResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SetGroupTargetIconRequest, ...grpc.CallOption) *pb.SetGroupTargetIconResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.SetGroupTargetIconResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.SetGroupTargetIconRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetLootMethod provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) SetLootMethod(ctx context.Context, in *pb.SetLootMethodRequest, opts ...grpc.CallOption) (*pb.SetLootMethodResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.SetLootMethodResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SetLootMethodRequest, ...grpc.CallOption) (*pb.SetLootMethodResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SetLootMethodRequest, ...grpc.CallOption) *pb.SetLootMethodResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.SetLootMethodResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.SetLootMethodRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetRaidDifficulty provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) SetRaidDifficulty(ctx context.Context, in *pb.SetRaidDifficultyRequest, opts ...grpc.CallOption) (*pb.SetRaidDifficultyResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.SetRaidDifficultyResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SetRaidDifficultyRequest, ...grpc.CallOption) (*pb.SetRaidDifficultyResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SetRaidDifficultyRequest, ...grpc.CallOption) *pb.SetRaidDifficultyResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.SetRaidDifficultyResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.SetRaidDifficultyRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Uninvite provides a mock function with given fields: ctx, in, opts
func (_m *GroupServiceClient) Uninvite(ctx context.Context, in *pb.UninviteParams, opts ...grpc.CallOption) (*pb.UninviteResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.UninviteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pb.UninviteParams, ...grpc.CallOption) (*pb.UninviteResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pb.UninviteParams, ...grpc.CallOption) *pb.UninviteResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.UninviteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pb.UninviteParams, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewGroupServiceClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewGroupServiceClient creates a new instance of GroupServiceClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewGroupServiceClient(t mockConstructorTestingTNewGroupServiceClient) *GroupServiceClient {
	mock := &GroupServiceClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
